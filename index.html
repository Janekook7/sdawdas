<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Demo - Two-way Remote Camera</title>
</head>
<body>
    <h2>Local Camera:</h2>
    <video id="localVideo" autoplay muted playsinline></video>

    <h2>Remote Camera:</h2>
    <video id="remoteVideo" autoplay playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js"></script>
    <script>
        const socket = io.connect('http://localhost:5000'); // Your signaling server URL

        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        let localStream;
        let peerConnection;

        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        async function start() {
            // 1. Get local media (camera)
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices.', error);
                return;
            }

            // 2. Create peer connection
            peerConnection = new RTCPeerConnection(config);

            // 3. Add local tracks to peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // 4. Handle incoming remote stream
            peerConnection.ontrack = ({ streams: [stream] }) => {
                remoteVideo.srcObject = stream;
            };

            // 5. ICE candidates
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    socket.emit('ice-candidate', candidate);
                }
            };

            // 6. Listen for offer/answer/candidates
            socket.on('offer', async (offer) => {
                console.log('Received offer');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('answer', answer);
            });

            socket.on('answer', async (answer) => {
                console.log('Received answer');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            });

            socket.on('ice-candidate', async (candidate) => {
                console.log('Received ICE candidate');
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                    console.error('Error adding received ice candidate', e);
                }
            });

            // 7. Tell server you're ready
            socket.emit('ready');
        }

        // When both tabs are ready, initiate call from one side
        let isInitiator = false;
        socket.on('ready', () => {
            if (!peerConnection) return;
            if (isInitiator) {
                createOffer();
            }
        });

        async function createOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit('offer', offer);
        }

        // Decide randomly who starts first
        socket.on('connect', () => {
            isInitiator = Math.random() < 0.5;
            console.log('Connected to signaling server. Initiator:', isInitiator);
            start();
        });

    </script>
</body>
</html>
